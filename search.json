[{"title":"Spring注解@PropertySource","path":"/2023/08/24/PropertySource注解/","content":"@PropertySource用于指定资源文件读取的位置 可以读取properties、xml、yml文件 可以通过YAML解析器搭配自定义PropertySourceFactory实现解析YAML文件 源码： 12345678910111213141516171819202122232425package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.io.support.PropertySourceFactory;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource &#123; String name() default &quot;&quot;; //指定资源名称，如果为空 根据基础资源描述生成 String[] value(); //指定资源路径 如：classpath:/xxx/xxx file:/xxx/xxx boolean ignoreResourceNotFound() default false; //是否忽略资源不存在的情况，如果不忽略 资源不存在就报错 默认为不忽略 String encoding() default &quot;&quot;; //指定文件编码格式 不指定就使用文件默认的 Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class; //指定资源工厂 不指定就使用默认工厂&#125;"},{"title":"ConfigurationProperties注解详解","path":"/2023/08/24/ConfigurationProperties注解详解/","content":"文章参考https://blog.csdn.net/skh2015java/article/details/120141409 @ConfigurationProperties注解用于获取配置文件中的属性定义并绑定到Java Bean上 该注解适用于具有相同前缀的属性，可以将配置文件中xxx开头的属性绑定到config里 12@ConfigurationProperties(prefix = &quot;gen&quot;)//将配置文件中所有为gen前缀的属性绑定到类中 将属性绑定到@Bean注释的方法上123456789@Configurationpublic class ConfigProperties &#123; @Bean @ConfigurationProperties(prefix = &quot;item&quot;) public Item item() &#123; return new Item(); &#125;&#125;"},{"title":"HttpClient 整理笔记","path":"/2023/08/24/HttpClient/","content":"HttpClientHttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 Get请求创建HttpClient实例 1CloseableHttpClient httpclient = HttpClients.createDefault(); 创建Get请求方法实例 1HttpGet httpGet= new HttpGet(&quot;http://xxxx&quot;) //传入url 调用HttpClient实例执行GET实例，返回response 1CloseableHttpResponse response = httpClient.execute(httpGet); 解析response 1234567// 获取状态码int status = response.getStatusLine().getStatusCode();// 获取实例HttpEntity entity = response.getEntity();// 获取htmlString html = EntityUtils.toString(entity); 释放连接 12response.close();httpClient.close(); Post请求 + 调用其它接口123456789101112131415161718192021222324252627282930313233String token=&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJhZG1pbiIsImlhdCI6MTY5MjE2NzAxOCwic3ViIjoiYWRtaW4iLCJleHAiOjE2OTI3NzE4MTh9.W81OP53vLyMuXJslYkFc7B_fiIX2UgfAlJhbH_YQhqA&quot;;//swagger tokenHttpClient httpClient = HttpClients.createDefault(); //创建实例String url=&quot;http://127.0.0.1:8271/web/varDataController/varSendData/&quot;+token; try &#123; HttpPost httpPost=new HttpPost(url); //创建post请求 通过url httpPost.setHeader(&quot;Content-Type&quot;,&quot;application/json&quot;); //设置请求头 设置什么取决于你的需求 以及 接口传参方式 // 设置POST的请求体 HttpEntity httpEntity=new StringEntity(&quot;&#123; &quot; + &quot; \\&quot;xxx\\&quot;: &#123;xx:\\&quot;xxx\\&quot;,xxx:\\&quot;xxxx\\&quot;,xxx:\\&quot;xxx\\&quot;,xxx:\\&quot;xx\\&quot;,qty:\\&quot;xxx\\&quot;,xxx:\\&quot;Carrier Id #xx\\&quot;,xx:\\&quot;xx\\&quot;,xx:\\&quot;2023-08-21\\&quot;,xxx:\\&quot;xxx\\&quot;&#125;, &quot; + &quot; \\&quot;facId\\&quot;: \\&quot;615\\&quot;, &quot; + &quot; \\&quot;xxx\\&quot;: \\&quot;EQU20171000000002\\&quot;, &quot; + &quot; \\&quot;xxxx\\&quot;: \\&quot;xxx\\&quot;, &quot; + &quot; \\&quot;time\\&quot;: \\&quot;2023-08-21\\&quot; &quot; + &quot;&#125;&quot;); //post请求可以进行传递参数 实际需要调用的接口也需要传递json格式数据 传什么因情况而异 httpPost.setEntity(httpEntity); //设置entity实体将需要传参的参数进行设置 HttpResponse response = httpClient.execute(httpPost); //执行post请求 获取response响应 StatusLine statusLine = response.getStatusLine(); //读取response状态 读取一行 int statusCode = statusLine.getStatusCode(); //获取状态码 比如 200，404，403，500等 if (statusCode== HttpStatus.SC_OK) &#123; //状态码是否为200 200即成功 HttpEntity responseEntity = response.getEntity(); //获取参数 String jsonString = EntityUtils.toString(responseEntity); //进行json转字符串 log.info(&quot;接口请求成功--------&quot;+jsonString); //输出日志 &#125;else &#123; log.error(&quot;请求返回：&quot;+ statusCode + &quot;(&quot;+url+&quot;)&quot;); &#125; long endTime = System.currentTimeMillis(); log.info(Thread.currentThread().getName() + &quot;开始于: &quot;+ startTime + &quot; 结束于: &quot; + endTime + &quot;, 花费: &quot; + (endTime - startTime) + &quot; ms.&quot; + &quot;Response: &quot;+response.getStatusLine().getStatusCode()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;"},{"title":"Hello World","path":"/2023/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]