[{"title":"Java 17 新特性","path":"/2023/08/30/Java  17新特性/","content":"Java 17新特性Sealed类它可以限制一个类的子类的数量，从而提高代码的安全性和可维护性。Sealed类可以通过sealed关键字来定义，然后使用permits子句来指定允许继承的子类。 123456789public sealed class Animals permits Dogs,Cats&#123;\t//Animals类定义&#125;public final class Dogs extends Animals&#123;\t//Dogs类的定义&#125;public final class Cats extends Animals&#123;\t//Cats类的定义&#125; 在上面示例的代码中，Animals被声明为sealed类，它只允许Dogs和Cats这两个类继承。除了这两个类 没有其它类可以继承Animals类。 Pattern Matching for instanceof它可以让开发人员更方便地使用 instanceof 运算符来进行类型匹配。这个特性可以让开发人员使用类似switch语句进行类型匹配，减少代码的错误率与复杂度 123456if (obj instanceof String str)&#123;\t//obj是一个字符串，可以使用str变量访问 sout(str.length());&#125;else&#123;\t//obj不是字符串&#125; 在上面示例代码中，使用 instanceof 运算符判断obj是否是一个字符串，如果是，我们可以使用str变量来访问它。 不同于以往的是 以前是直接判断左边对象是否是右边类的实例 判断类型，现在如果是右边类型的话可以使用变量进行访问。 垃圾回收器的改进Java 17对垃圾回收器进行了改进，其中包括对垃圾回收器的性能和内存利用率进行优化。 12345// 创建一个大对象byte[] bigObject = new byte[1024 * 1024 * 100];// 手动触发垃圾回收System.gc(); Http&#x2F;2客户端该特性可以让开发人员更方便地使用HTTP&#x2F;2协议来进行网络通信。HTTP&#x2F;2客户端可以提供更快的网络传输速度和更低的延迟，从而提高应用程序的性能和用户体验。 1234567891011//创建Http/2 客户端HttpClient client = HttpClient.newHttpClient();//创建一个Http请求HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(&quot;https://www.example.com&quot;)) .build();//发送Http 请求并获取响应HttpResponse&lt;String&gt; response = client.send(request,HttpResponse.BodyHandlers.ofString());//输出响应内容sout(response.body()); Vector API这个特性可以让开发人员更方便地使用向量来操作数据处理，Vector 提供了更好的性能与更高的并行性，从而加速数据处理过程。 123456// 创建一个VectorVector&lt;Float&gt; vector=Vector.of(1.0f,2.0f,3.0f,4.0f);//对Vector中的元素进行操作Vector&lt;Float&gt; result= vector.map(x -&gt; x*2).add(Vector.of(1.0f,1.0f,1.0f,1.0f));//输出sout(result); 在上面的示例代码中，我们创建了一个 Vector，并对其进行了一些操作，包括对每个元素乘以 2，然后加上另一个 Vector。 Switch表达式的增强Java 17中对Switch 表达式进行了增强，其中包括对 Switch 表达式的模式匹配进行了优化。这些改进可以让开发人员更方便地使用 Switch 表达式来进行条件判断和分支控制。 123456789101112int dayOfWeek =1;String dayName=switch(dayOfWeek)&#123; case 1 -&gt; &quot;Monday&quot;; case 2 -&gt; &quot;Tuesday&quot;; case 3 -&gt; &quot;Wednesday&quot;; case 4 -&gt; &quot;Thursday&quot;; case 5 -&gt; &quot;Friday&quot;; case 6 -&gt; &quot;Saturday&quot;; case 7 -&gt; &quot;Sunday&quot;; default -&gt; throw new IllegalArgumentException(&quot;Invalid day of week: &quot; + dayOfWeek);&#125;; Sout(dayName);&#125; 参考文献&#x2F;博客https://blog.csdn.net/qq_42055933/article/details/131407352"},{"title":"Spring注解@PropertySource","path":"/2023/08/24/PropertySource注解/","content":"@PropertySource用于指定资源文件读取的位置 可以读取properties、xml、yml文件 可以通过YAML解析器搭配自定义PropertySourceFactory实现解析YAML文件 源码： 12345678910111213141516171819202122232425package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.io.support.PropertySourceFactory;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource &#123; String name() default &quot;&quot;; //指定资源名称，如果为空 根据基础资源描述生成 String[] value(); //指定资源路径 如：classpath:/xxx/xxx file:/xxx/xxx boolean ignoreResourceNotFound() default false; //是否忽略资源不存在的情况，如果不忽略 资源不存在就报错 默认为不忽略 String encoding() default &quot;&quot;; //指定文件编码格式 不指定就使用文件默认的 Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class; //指定资源工厂 不指定就使用默认工厂&#125;"},{"title":"ConfigurationProperties注解详解","path":"/2023/08/24/ConfigurationProperties注解详解/","content":"文章参考https://blog.csdn.net/skh2015java/article/details/120141409 @ConfigurationProperties注解用于获取配置文件中的属性定义并绑定到Java Bean上 该注解适用于具有相同前缀的属性，可以将配置文件中xxx开头的属性绑定到config里 12@ConfigurationProperties(prefix = &quot;gen&quot;)//将配置文件中所有为gen前缀的属性绑定到类中 将属性绑定到@Bean注释的方法上123456789@Configurationpublic class ConfigProperties &#123; @Bean @ConfigurationProperties(prefix = &quot;item&quot;) public Item item() &#123; return new Item(); &#125;&#125;"},{"title":"HttpClient 整理笔记","path":"/2023/08/24/HttpClient/","content":"HttpClientHttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 Get请求创建HttpClient实例 1CloseableHttpClient httpclient = HttpClients.createDefault(); 创建Get请求方法实例 1HttpGet httpGet= new HttpGet(&quot;http://xxxx&quot;) //传入url 调用HttpClient实例执行GET实例，返回response 1CloseableHttpResponse response = httpClient.execute(httpGet); 解析response 1234567// 获取状态码int status = response.getStatusLine().getStatusCode();// 获取实例HttpEntity entity = response.getEntity();// 获取htmlString html = EntityUtils.toString(entity); 释放连接 12response.close();httpClient.close(); Post请求 + 调用其它接口123456789101112131415161718192021222324252627282930313233String token=&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJhZG1pbiIsImlhdCI6MTY5MjE2NzAxOCwic3ViIjoiYWRtaW4iLCJleHAiOjE2OTI3NzE4MTh9.W81OP53vLyMuXJslYkFc7B_fiIX2UgfAlJhbH_YQhqA&quot;;//swagger tokenHttpClient httpClient = HttpClients.createDefault(); //创建实例String url=&quot;http://127.0.0.1:8271/web/varDataController/varSendData/&quot;+token; try &#123; HttpPost httpPost=new HttpPost(url); //创建post请求 通过url httpPost.setHeader(&quot;Content-Type&quot;,&quot;application/json&quot;); //设置请求头 设置什么取决于你的需求 以及 接口传参方式 // 设置POST的请求体 HttpEntity httpEntity=new StringEntity(&quot;&#123; &quot; + &quot; \\&quot;xxx\\&quot;: &#123;xx:\\&quot;xxx\\&quot;,xxx:\\&quot;xxxx\\&quot;,xxx:\\&quot;xxx\\&quot;,xxx:\\&quot;xx\\&quot;,qty:\\&quot;xxx\\&quot;,xxx:\\&quot;Carrier Id #xx\\&quot;,xx:\\&quot;xx\\&quot;,xx:\\&quot;2023-08-21\\&quot;,xxx:\\&quot;xxx\\&quot;&#125;, &quot; + &quot; \\&quot;facId\\&quot;: \\&quot;615\\&quot;, &quot; + &quot; \\&quot;xxx\\&quot;: \\&quot;EQU20171000000002\\&quot;, &quot; + &quot; \\&quot;xxxx\\&quot;: \\&quot;xxx\\&quot;, &quot; + &quot; \\&quot;time\\&quot;: \\&quot;2023-08-21\\&quot; &quot; + &quot;&#125;&quot;); //post请求可以进行传递参数 实际需要调用的接口也需要传递json格式数据 传什么因情况而异 httpPost.setEntity(httpEntity); //设置entity实体将需要传参的参数进行设置 HttpResponse response = httpClient.execute(httpPost); //执行post请求 获取response响应 StatusLine statusLine = response.getStatusLine(); //读取response状态 读取一行 int statusCode = statusLine.getStatusCode(); //获取状态码 比如 200，404，403，500等 if (statusCode== HttpStatus.SC_OK) &#123; //状态码是否为200 200即成功 HttpEntity responseEntity = response.getEntity(); //获取参数 String jsonString = EntityUtils.toString(responseEntity); //进行json转字符串 log.info(&quot;接口请求成功--------&quot;+jsonString); //输出日志 &#125;else &#123; log.error(&quot;请求返回：&quot;+ statusCode + &quot;(&quot;+url+&quot;)&quot;); &#125; long endTime = System.currentTimeMillis(); log.info(Thread.currentThread().getName() + &quot;开始于: &quot;+ startTime + &quot; 结束于: &quot; + endTime + &quot;, 花费: &quot; + (endTime - startTime) + &quot; ms.&quot; + &quot;Response: &quot;+response.getStatusLine().getStatusCode()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;"},{"title":"Hello World","path":"/2023/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]